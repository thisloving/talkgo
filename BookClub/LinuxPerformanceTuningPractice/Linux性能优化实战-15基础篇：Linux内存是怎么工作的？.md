## 内存映射

​		Linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。虚拟地址空间的内部又被分为内核空间和用户空间两部分。

​		进程在用户态时，只能访问用户空间内存；只有进入内核态后，才可以访问内核空间内存。而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

​		页的大小只有 4 KB，Linux 提供了两种机制，也就是多级页表和大页（HugePage）。

## 虚拟内存空间分布

+ 只读段，包括代码和常量等。
+ 数据段，包括全局变量等
+ 堆，包括动态分配的内存，从低地址开始向上增长。
+ 文件映射段，包括动态库、共享内存等，从高地址开始向下增长。
+ 栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。

## 内存分配与回收

+ 对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。
+ 大块内存（大于 128K），则直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去

brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率。不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片。

mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大。这也是 malloc 只对大块内存使用 mmap  的原因。

两种调用发生后，其实并没有真正分配内存。这些内存，都只在首次访问时才分配，也就是通过缺页异常进入内核中，再由内核来分配内存。

#### 回收内存，三种方式：

+ 回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面；

+ 回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；
+ 杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。

## 如何查看内存使用情况

```
root@ubuntu:/home/leving# free
              total        used        free      shared  buff/cache   available
Mem:        8124916     1763432     4344236        3984     2017248     6051812
Swap:       2097148           0     2097148
```

+ 第一列，total 是总内存大小；

+ 第二列，used 是已使用内存的大小，包含了共享内存；
+ 第三列，free 是未使用内存的大小；
+ 第四列，shared 是共享内存的大小；
+ 第五列，buff/cache 是缓存和缓冲区的大小；
+ 最后一列，available 是新进程可用内存的大小。

top 查看信息

+ VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。
+ RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。
+ SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。

第一，虚拟内存通常并不会全部分配物理内存。

第二，共享内存 SHR 并不一定是共享的，比方说，程序的代码段、非共享的动态链接库，也都算在 SHR 里。

## 小结

当进程通过 malloc() 申请内存后，内存并不会立即分配，而是在首次访问时，才通过缺页异常陷入内核中分配内存。